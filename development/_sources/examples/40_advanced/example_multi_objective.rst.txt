
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/40_advanced/example_multi_objective.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_40_advanced_example_multi_objective.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_40_advanced_example_multi_objective.py:


==============
Classification
==============

The following example shows how to fit *auto-sklearn* to optimize for two
competing metrics: `precision` and `recall` (read more on this tradeoff
in the `scikit-learn docs <https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html>`_.

Auto-sklearn uses `SMAC3's implementation of ParEGO <https://automl.github.io/SMAC3/main/details/multi_objective.html>`_.
Multi-objective ensembling and proper access to the full Pareto front will be added in the near
future.

.. GENERATED FROM PYTHON SOURCE LINES 15-24

.. code-block:: default

    from pprint import pprint

    import sklearn.datasets
    import sklearn.metrics

    import autosklearn.classification
    import autosklearn.metrics









.. GENERATED FROM PYTHON SOURCE LINES 25-27

Data Loading
============

.. GENERATED FROM PYTHON SOURCE LINES 27-33

.. code-block:: default


    X, y = sklearn.datasets.load_breast_cancer(return_X_y=True)
    X_train, X_test, y_train, y_test = sklearn.model_selection.train_test_split(
        X, y, random_state=1
    )








.. GENERATED FROM PYTHON SOURCE LINES 34-36

Build and fit a classifier
==========================

.. GENERATED FROM PYTHON SOURCE LINES 36-44

.. code-block:: default


    automl = autosklearn.classification.AutoSklearnClassifier(
        time_left_for_this_task=30,
        tmp_folder="/tmp/autosklearn_multi_objective_example_tmp",
        metric=[autosklearn.metrics.precision, autosklearn.metrics.recall],
    )
    automl.fit(X_train, y_train, dataset_name="breast_cancer")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/auto-sklearn/auto-sklearn/autosklearn/metalearning/metalearning/meta_base.py:76: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.
      self.metafeatures = self.metafeatures.append(metafeatures)
    /home/runner/work/auto-sklearn/auto-sklearn/autosklearn/metalearning/metalearning/meta_base.py:80: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.
      self.algorithm_runs[metric].append(runs)

    AutoSklearnClassifier(metric=[precision, recall], per_run_time_limit=3,
                          time_left_for_this_task=30,
                          tmp_folder='/tmp/autosklearn_multi_objective_example_tmp')



.. GENERATED FROM PYTHON SOURCE LINES 45-47

Compute the two competing metrics
=================================

.. GENERATED FROM PYTHON SOURCE LINES 47-52

.. code-block:: default


    predictions = automl.predict(X_test)
    print("Precision", sklearn.metrics.precision_score(y_test, predictions))
    print("Recall", sklearn.metrics.recall_score(y_test, predictions))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Precision 0.945054945054945
    Recall 0.9772727272727273




.. GENERATED FROM PYTHON SOURCE LINES 53-56

View the models found by auto-sklearn
=====================================
They are by default sorted by the first metric given to *auto-sklearn*.

.. GENERATED FROM PYTHON SOURCE LINES 56-59

.. code-block:: default


    print(automl.leaderboard())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

              rank  ensemble_weight           type    cost_0    cost_1  duration
    model_id                                                                    
    2            2             0.20  random_forest  0.022472  0.022472  2.457621
    3            5             0.20            mlp  0.043011  0.000000  1.568343
    4            6             0.06            mlp  0.054945  0.033708  2.324665
    5            4             0.14  random_forest  0.033333  0.022472  2.879892
    6            1             0.10  random_forest  0.021978  0.000000  2.740491
    7            3             0.30  random_forest  0.022472  0.022472  2.338183




.. GENERATED FROM PYTHON SOURCE LINES 60-64

``cv_results`` also contains both metrics
=========================================
Similarly to the leaderboard, they are sorted by the first metric given
to *auto-sklearn*.

.. GENERATED FROM PYTHON SOURCE LINES 64-66

.. code-block:: default


    pprint(automl.cv_results_)




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'budgets': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],
     'mean_fit_time': array([2.45762086, 1.56834292, 2.32466459, 2.87989211, 2.74049115,
           2.33818269, 1.00717211]),
     'mean_test_precision': array([0.97752809, 0.95698925, 0.94505495, 0.96666667, 0.97802198,
           0.97752809, 0.        ]),
     'mean_test_recall': array([0.97752809, 1.        , 0.96629213, 0.97752809, 1.        ,
           0.97752809, 0.        ]),
     'param_balancing:strategy': masked_array(data=['none', 'none', 'weighting', 'weighting', 'weighting',
                       'none', 'none'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U9'),
     'param_classifier:__choice__': masked_array(data=['random_forest', 'mlp', 'mlp', 'random_forest',
                       'random_forest', 'random_forest', 'adaboost'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U13'),
     'param_classifier:adaboost:algorithm': masked_array(data=[--, --, --, --, --, --, 'SAMME'],
                 mask=[ True,  True,  True,  True,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:adaboost:learning_rate': masked_array(data=[--, --, --, --, --, --, 0.08969800736685585],
                 mask=[ True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20),
     'param_classifier:adaboost:max_depth': masked_array(data=[--, --, --, --, --, --, 4.0],
                 mask=[ True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20),
     'param_classifier:adaboost:n_estimators': masked_array(data=[--, --, --, --, --, --, 477.0],
                 mask=[ True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20),
     'param_classifier:bernoulli_nb:alpha': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:bernoulli_nb:fit_prior': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:criterion': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:max_depth_factor': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:max_features': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:min_samples_split': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:decision_tree:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:bootstrap': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:criterion': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:max_depth': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:max_features': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:min_samples_split': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:extra_trees:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:early_stop': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:l2_regularization': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:learning_rate': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:loss': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:max_bins': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:max_depth': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:n_iter_no_change': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:scoring': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:tol': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:gradient_boosting:validation_fraction': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:k_nearest_neighbors:n_neighbors': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:k_nearest_neighbors:p': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:k_nearest_neighbors:weights': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:lda:shrinkage': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:lda:shrinkage_factor': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:lda:tol': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:C': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:dual': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:fit_intercept': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:intercept_scaling': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:loss': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:multi_class': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:penalty': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:liblinear_svc:tol': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:C': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:coef0': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:degree': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:gamma': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:kernel': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:max_iter': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:shrinking': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:libsvm_svc:tol': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:mlp:activation': masked_array(data=[--, 'tanh', 'tanh', --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:alpha': masked_array(data=[--, 0.0001363185819149026, 0.00021148999718383549, --,
                       --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:batch_size': masked_array(data=[--, 'auto', 'auto', --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:beta_1': masked_array(data=[--, 0.9, 0.9, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:beta_2': masked_array(data=[--, 0.999, 0.999, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:early_stopping': masked_array(data=[--, 'valid', 'train', --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:epsilon': masked_array(data=[--, 1e-08, 1e-08, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:hidden_layer_depth': masked_array(data=[--, 3.0, 3.0, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:learning_rate_init': masked_array(data=[--, 0.00018009776276177523, 0.0007452270241186694, --,
                       --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:n_iter_no_change': masked_array(data=[--, 32.0, 32.0, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:num_nodes_per_layer': masked_array(data=[--, 115.0, 113.0, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:shuffle': masked_array(data=[--, 'True', 'True', --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:solver': masked_array(data=[--, 'adam', 'adam', --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:mlp:tol': masked_array(data=[--, 0.0001, 0.0001, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:mlp:validation_fraction': masked_array(data=[--, 0.1, --, --, --, --, --],
                 mask=[ True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_classifier:multinomial_nb:alpha': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:multinomial_nb:fit_prior': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:passive_aggressive:C': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:passive_aggressive:average': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:passive_aggressive:fit_intercept': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:passive_aggressive:loss': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:passive_aggressive:tol': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:qda:reg_param': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:random_forest:bootstrap': masked_array(data=['True', --, --, 'True', 'True', 'True', --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:random_forest:criterion': masked_array(data=['gini', --, --, 'entropy', 'gini', 'entropy', --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:random_forest:max_depth': masked_array(data=['None', --, --, 'None', 'None', 'None', --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:random_forest:max_features': masked_array(data=[0.5, --, --, 0.4775492074518431, 0.48532133444855097,
                       0.4784709727277252, --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value=1e+20),
     'param_classifier:random_forest:max_leaf_nodes': masked_array(data=['None', --, --, 'None', 'None', 'None', --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_classifier:random_forest:min_impurity_decrease': masked_array(data=[0.0, --, --, 0.0, 0.0, 0.0, --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value=1e+20),
     'param_classifier:random_forest:min_samples_leaf': masked_array(data=[1.0, --, --, 2.0, 1.0, 1.0, --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value=1e+20),
     'param_classifier:random_forest:min_samples_split': masked_array(data=[2.0, --, --, 2.0, 2.0, 14.0, --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value=1e+20),
     'param_classifier:random_forest:min_weight_fraction_leaf': masked_array(data=[0.0, --, --, 0.0, 0.0, 0.0, --],
                 mask=[False,  True,  True, False, False, False,  True],
           fill_value=1e+20),
     'param_classifier:sgd:alpha': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:average': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:epsilon': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:eta0': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:fit_intercept': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:l1_ratio': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:learning_rate': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:loss': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:penalty': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:power_t': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_classifier:sgd:tol': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:__choice__': masked_array(data=['feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U12'),
     'param_data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': masked_array(data=['one_hot_encoding', 'no_encoding', 'one_hot_encoding',
                       'no_encoding', 'no_encoding', 'no_encoding',
                       'no_encoding'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U16'),
     'param_data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': masked_array(data=['minority_coalescer', 'no_coalescense',
                       'no_coalescense', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'minority_coalescer'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U18'),
     'param_data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': masked_array(data=[0.01, --, --, 0.015996368052062886,
                       0.010000000000000004, --, 0.019736646248307184],
                 mask=[False,  True,  True, False, False,  True, False],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:numerical_transformer:imputation:strategy': masked_array(data=['mean', 'median', 'most_frequent', 'most_frequent',
                       'mean', 'most_frequent', 'mean'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U13'),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': masked_array(data=['standardize', 'standardize', 'standardize',
                       'robust_scaler', 'minmax', 'none',
                       'quantile_transformer'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U20'),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': masked_array(data=[--, --, --, --, --, --, 490.0],
                 mask=[ True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': masked_array(data=[--, --, --, --, --, --, 'uniform'],
                 mask=[ True,  True,  True,  True,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': masked_array(data=[--, --, --, 0.7845396961078424, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': masked_array(data=[--, --, --, 0.25545052141264185, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True],
           fill_value=1e+20),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': masked_array(data=['bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U20'),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': masked_array(data=[0, 1, 1, 1, 1, 1, 1],
                 mask=[False, False, False, False, False, False, False],
           fill_value=999999),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': masked_array(data=['min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U15'),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_relative': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': masked_array(data=[1, 1, 1, 1, 1, 1, 1],
                 mask=[False, False, False, False, False, False, False],
           fill_value=999999),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_absolute': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_choice': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_relative': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:ngram_upper_bound': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_absolute': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_choice': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_relative': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:ngram_upper_bound': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:use_idf': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': masked_array(data=[100, 100, 100, 100, 100, 100, 100],
                 mask=[False, False, False, False, False, False, False],
           fill_value=999999),
     'param_feature_preprocessor:__choice__': masked_array(data=['no_preprocessing', 'feature_agglomeration',
                       'feature_agglomeration',
                       'extra_trees_preproc_for_classification', 'fast_ica',
                       'select_rates_classification',
                       'extra_trees_preproc_for_classification'],
                 mask=[False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U38'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:bootstrap': masked_array(data=[--, --, --, 'False', --, --, 'False'],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:criterion': masked_array(data=[--, --, --, 'entropy', --, --, 'gini'],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:max_depth': masked_array(data=[--, --, --, 'None', --, --, 'None'],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:max_features': masked_array(data=[--, --, --, 0.5662900693317384, --, --,
                       0.7702392905650387],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:max_leaf_nodes': masked_array(data=[--, --, --, 'None', --, --, 'None'],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:min_impurity_decrease': masked_array(data=[--, --, --, 0.0, --, --, 0.0],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:min_samples_leaf': masked_array(data=[--, --, --, 1.0, --, --, 15.0],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:min_samples_split': masked_array(data=[--, --, --, 7.0, --, --, 13.0],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:min_weight_fraction_leaf': masked_array(data=[--, --, --, 0.0, --, --, 0.0],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value=1e+20),
     'param_feature_preprocessor:extra_trees_preproc_for_classification:n_estimators': masked_array(data=[--, --, --, 100.0, --, --, 100.0],
                 mask=[ True,  True,  True, False,  True,  True, False],
           fill_value=1e+20),
     'param_feature_preprocessor:fast_ica:algorithm': masked_array(data=[--, --, --, --, 'parallel', --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:fast_ica:fun': masked_array(data=[--, --, --, --, 'cube', --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:fast_ica:n_components': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:fast_ica:whiten': masked_array(data=[--, --, --, --, 'False', --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:feature_agglomeration:affinity': masked_array(data=[--, 'euclidean', 'euclidean', --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:feature_agglomeration:linkage': masked_array(data=[--, 'ward', 'complete', --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:feature_agglomeration:n_clusters': masked_array(data=[--, 182.0, 247.0, --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value=1e+20),
     'param_feature_preprocessor:feature_agglomeration:pooling_func': masked_array(data=[--, 'mean', 'max', --, --, --, --],
                 mask=[ True, False, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:kernel_pca:coef0': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kernel_pca:degree': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kernel_pca:gamma': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kernel_pca:kernel': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kernel_pca:n_components': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kitchen_sinks:gamma': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:kitchen_sinks:n_components': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:C': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:dual': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:fit_intercept': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:intercept_scaling': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:loss': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:multi_class': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:penalty': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:liblinear_svc_preprocessor:tol': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:coef0': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:degree': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:gamma': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:kernel': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:nystroem_sampler:n_components': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:pca:keep_variance': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:pca:whiten': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:polynomial:degree': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:polynomial:include_bias': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:polynomial:interaction_only': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:bootstrap': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:max_depth': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:min_samples_split': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:random_trees_embedding:n_estimators': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:select_percentile_classification:percentile': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:select_percentile_classification:score_func': masked_array(data=[--, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64),
     'param_feature_preprocessor:select_rates_classification:alpha': masked_array(data=[--, --, --, --, --, 0.46621681976184837, --],
                 mask=[ True,  True,  True,  True,  True, False,  True],
           fill_value=1e+20),
     'param_feature_preprocessor:select_rates_classification:mode': masked_array(data=[--, --, --, --, --, 'fpr', --],
                 mask=[ True,  True,  True,  True,  True, False,  True],
           fill_value='N/A',
                dtype='<U32'),
     'param_feature_preprocessor:select_rates_classification:score_func': masked_array(data=[--, --, --, --, --, 'chi2', --],
                 mask=[ True,  True,  True,  True,  True, False,  True],
           fill_value='N/A',
                dtype='<U32'),
     'params': [{'balancing:strategy': 'none',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'True',
                 'classifier:random_forest:criterion': 'gini',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.5,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 1,
                 'classifier:random_forest:min_samples_split': 2,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.01,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 0,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'no_preprocessing'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'mlp',
                 'classifier:mlp:activation': 'tanh',
                 'classifier:mlp:alpha': 0.0001363185819149026,
                 'classifier:mlp:batch_size': 'auto',
                 'classifier:mlp:beta_1': 0.9,
                 'classifier:mlp:beta_2': 0.999,
                 'classifier:mlp:early_stopping': 'valid',
                 'classifier:mlp:epsilon': 1e-08,
                 'classifier:mlp:hidden_layer_depth': 3,
                 'classifier:mlp:learning_rate_init': 0.00018009776276177523,
                 'classifier:mlp:n_iter_no_change': 32,
                 'classifier:mlp:num_nodes_per_layer': 115,
                 'classifier:mlp:shuffle': 'True',
                 'classifier:mlp:solver': 'adam',
                 'classifier:mlp:tol': 0.0001,
                 'classifier:mlp:validation_fraction': 0.1,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'feature_agglomeration',
                 'feature_preprocessor:feature_agglomeration:affinity': 'euclidean',
                 'feature_preprocessor:feature_agglomeration:linkage': 'ward',
                 'feature_preprocessor:feature_agglomeration:n_clusters': 182,
                 'feature_preprocessor:feature_agglomeration:pooling_func': 'mean'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'mlp',
                 'classifier:mlp:activation': 'tanh',
                 'classifier:mlp:alpha': 0.00021148999718383549,
                 'classifier:mlp:batch_size': 'auto',
                 'classifier:mlp:beta_1': 0.9,
                 'classifier:mlp:beta_2': 0.999,
                 'classifier:mlp:early_stopping': 'train',
                 'classifier:mlp:epsilon': 1e-08,
                 'classifier:mlp:hidden_layer_depth': 3,
                 'classifier:mlp:learning_rate_init': 0.0007452270241186694,
                 'classifier:mlp:n_iter_no_change': 32,
                 'classifier:mlp:num_nodes_per_layer': 113,
                 'classifier:mlp:shuffle': 'True',
                 'classifier:mlp:solver': 'adam',
                 'classifier:mlp:tol': 0.0001,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'feature_agglomeration',
                 'feature_preprocessor:feature_agglomeration:affinity': 'euclidean',
                 'feature_preprocessor:feature_agglomeration:linkage': 'complete',
                 'feature_preprocessor:feature_agglomeration:n_clusters': 247,
                 'feature_preprocessor:feature_agglomeration:pooling_func': 'max'},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'True',
                 'classifier:random_forest:criterion': 'entropy',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.4775492074518431,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 2,
                 'classifier:random_forest:min_samples_split': 2,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.015996368052062886,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'robust_scaler',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': 0.7845396961078424,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': 0.25545052141264185,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'extra_trees_preproc_for_classification',
                 'feature_preprocessor:extra_trees_preproc_for_classification:bootstrap': 'False',
                 'feature_preprocessor:extra_trees_preproc_for_classification:criterion': 'entropy',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_depth': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_features': 0.5662900693317384,
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_leaf_nodes': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_impurity_decrease': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_leaf': 1,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_split': 7,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_weight_fraction_leaf': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:n_estimators': 100},
                {'balancing:strategy': 'weighting',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'True',
                 'classifier:random_forest:criterion': 'gini',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.48532133444855097,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 1,
                 'classifier:random_forest:min_samples_split': 2,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.010000000000000004,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'minmax',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'fast_ica',
                 'feature_preprocessor:fast_ica:algorithm': 'parallel',
                 'feature_preprocessor:fast_ica:fun': 'cube',
                 'feature_preprocessor:fast_ica:whiten': 'False'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'random_forest',
                 'classifier:random_forest:bootstrap': 'True',
                 'classifier:random_forest:criterion': 'entropy',
                 'classifier:random_forest:max_depth': 'None',
                 'classifier:random_forest:max_features': 0.4784709727277252,
                 'classifier:random_forest:max_leaf_nodes': 'None',
                 'classifier:random_forest:min_impurity_decrease': 0.0,
                 'classifier:random_forest:min_samples_leaf': 1,
                 'classifier:random_forest:min_samples_split': 14,
                 'classifier:random_forest:min_weight_fraction_leaf': 0.0,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense',
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'none',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'select_rates_classification',
                 'feature_preprocessor:select_rates_classification:alpha': 0.46621681976184837,
                 'feature_preprocessor:select_rates_classification:mode': 'fpr',
                 'feature_preprocessor:select_rates_classification:score_func': 'chi2'},
                {'balancing:strategy': 'none',
                 'classifier:__choice__': 'adaboost',
                 'classifier:adaboost:algorithm': 'SAMME',
                 'classifier:adaboost:learning_rate': 0.08969800736685585,
                 'classifier:adaboost:max_depth': 4,
                 'classifier:adaboost:n_estimators': 477,
                 'data_preprocessor:__choice__': 'feature_type',
                 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
                 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.019736646248307184,
                 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer',
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 490,
                 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
                 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
                 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
                 'feature_preprocessor:__choice__': 'extra_trees_preproc_for_classification',
                 'feature_preprocessor:extra_trees_preproc_for_classification:bootstrap': 'False',
                 'feature_preprocessor:extra_trees_preproc_for_classification:criterion': 'gini',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_depth': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_features': 0.7702392905650387,
                 'feature_preprocessor:extra_trees_preproc_for_classification:max_leaf_nodes': 'None',
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_impurity_decrease': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_leaf': 15,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_samples_split': 13,
                 'feature_preprocessor:extra_trees_preproc_for_classification:min_weight_fraction_leaf': 0.0,
                 'feature_preprocessor:extra_trees_preproc_for_classification:n_estimators': 100}],
     'rank_test_precision': array([2, 5, 6, 4, 1, 2, 7]),
     'rank_test_recall': array([3, 1, 6, 3, 1, 3, 7]),
     'status': ['Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Success',
                'Timeout']}





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  40.019 seconds)


.. _sphx_glr_download_examples_40_advanced_example_multi_objective.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/automl/auto-sklearn/master?urlpath=lab/tree/notebooks/examples/40_advanced/example_multi_objective.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: example_multi_objective.py <example_multi_objective.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: example_multi_objective.ipynb <example_multi_objective.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
