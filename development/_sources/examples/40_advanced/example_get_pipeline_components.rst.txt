
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/40_advanced/example_get_pipeline_components.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_40_advanced_example_get_pipeline_components.py>`
        to download the full example code or to run this example in your browser via Binder

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_40_advanced_example_get_pipeline_components.py:


======================
Obtain run information
======================

The following example shows how to obtain information from a finished
Auto-sklearn run. In particular, it shows:
* how to query which models were evaluated by Auto-sklearn
* how to query the models in the final ensemble
* how to get general statistics on the what Auto-sklearn evaluated

Auto-sklearn is a wrapper on top of
the sklearn models. This example illustrates how to interact
with the sklearn components directly, in this case a PCA preprocessor.

.. GENERATED FROM PYTHON SOURCE LINES 17-25

.. code-block:: default

    from pprint import pprint

    import sklearn.datasets
    import sklearn.metrics

    import autosklearn.classification









.. GENERATED FROM PYTHON SOURCE LINES 26-28

Data Loading
============

.. GENERATED FROM PYTHON SOURCE LINES 28-34

.. code-block:: default


    X, y = sklearn.datasets.load_breast_cancer(return_X_y=True)
    X_train, X_test, y_train, y_test = sklearn.model_selection.train_test_split(
        X, y, random_state=1
    )








.. GENERATED FROM PYTHON SOURCE LINES 35-37

Build and fit the classifier
============================

.. GENERATED FROM PYTHON SOURCE LINES 37-48

.. code-block:: default


    automl = autosklearn.classification.AutoSklearnClassifier(
        time_left_for_this_task=30,
        per_run_time_limit=10,
        disable_evaluator_output=False,
        # To simplify querying the models in the final ensemble, we
        # restrict auto-sklearn to use only pca as a preprocessor
        include={"feature_preprocessor": ["pca"]},
    )
    automl.fit(X_train, y_train, dataset_name="breast_cancer")





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    /home/runner/work/auto-sklearn/auto-sklearn/autosklearn/metalearning/metalearning/meta_base.py:76: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.
      self.metafeatures = self.metafeatures.append(metafeatures)
    /home/runner/work/auto-sklearn/auto-sklearn/autosklearn/metalearning/metalearning/meta_base.py:80: FutureWarning: The frame.append method is deprecated and will be removed from pandas in a future version. Use pandas.concat instead.
      self.algorithm_runs[metric].append(runs)

    AutoSklearnClassifier(include={'feature_preprocessor': ['pca']},
                          per_run_time_limit=10, time_left_for_this_task=30)



.. GENERATED FROM PYTHON SOURCE LINES 49-51

Predict using the model
=======================

.. GENERATED FROM PYTHON SOURCE LINES 51-56

.. code-block:: default


    predictions = automl.predict(X_test)
    print("Accuracy score:{}".format(sklearn.metrics.accuracy_score(y_test, predictions)))






.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Accuracy score:0.958041958041958




.. GENERATED FROM PYTHON SOURCE LINES 57-73

Report the models found by Auto-Sklearn
=======================================

Auto-sklearn uses
`Ensemble Selection <https://www.cs.cornell.edu/~alexn/papers/shotgun.icml04.revised.rev2.pdf>`_
to construct ensembles in a post-hoc fashion. The ensemble is a linear
weighting of all models constructed during the hyperparameter optimization.
This prints the final ensemble. It is a dictionary where ``model_id`` of
each model is a key, and value is a dictionary containing information
of that model. A model's dict contains its ``'model_id'``, ``'rank'``,
``'cost'``, ``'ensemble_weight'``, and the model itself. The model is
given by the ``'data_preprocessor'``, ``'feature_preprocessor'``,
``'regressor'/'classifier'`` and ``'sklearn_regressor'/'sklearn_classifier'``
entries. But for the ``'cv'`` resampling strategy, the same for each cv
model is stored in the ``'estimators'`` list in the dict, along with the
``'voting_model'``.

.. GENERATED FROM PYTHON SOURCE LINES 73-76

.. code-block:: default


    pprint(automl.show_models(), indent=4)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {   2: {   'balancing': Balancing(random_state=1),
               'classifier': <autosklearn.pipeline.components.classification.ClassifierChoice object at 0x7f099cb59f70>,
               'cost': 0.07801418439716312,
               'data_preprocessor': <autosklearn.pipeline.components.data_preprocessing.DataPreprocessorChoice object at 0x7f099c23c610>,
               'ensemble_weight': 0.08,
               'feature_preprocessor': <autosklearn.pipeline.components.feature_preprocessing.FeaturePreprocessorChoice object at 0x7f09bd0ba640>,
               'model_id': 2,
               'rank': 1,
               'sklearn_classifier': RandomForestClassifier(max_features=5, n_estimators=512, n_jobs=1,
                           random_state=1, warm_start=True)},
        3: {   'balancing': Balancing(random_state=1),
               'classifier': <autosklearn.pipeline.components.classification.ClassifierChoice object at 0x7f099f25eca0>,
               'cost': 0.07092198581560283,
               'data_preprocessor': <autosklearn.pipeline.components.data_preprocessing.DataPreprocessorChoice object at 0x7f099c23ce50>,
               'ensemble_weight': 0.16,
               'feature_preprocessor': <autosklearn.pipeline.components.feature_preprocessing.FeaturePreprocessorChoice object at 0x7f099f25e640>,
               'model_id': 3,
               'rank': 2,
               'sklearn_classifier': RandomForestClassifier(max_features=1, min_samples_leaf=2, min_samples_split=20,
                           n_estimators=512, n_jobs=1, random_state=1,
                           warm_start=True)},
        4: {   'balancing': Balancing(random_state=1, strategy='weighting'),
               'classifier': <autosklearn.pipeline.components.classification.ClassifierChoice object at 0x7f09a10a0be0>,
               'cost': 0.028368794326241176,
               'data_preprocessor': <autosklearn.pipeline.components.data_preprocessing.DataPreprocessorChoice object at 0x7f099bddc1c0>,
               'ensemble_weight': 0.2,
               'feature_preprocessor': <autosklearn.pipeline.components.feature_preprocessing.FeaturePreprocessorChoice object at 0x7f09a11c4ca0>,
               'model_id': 4,
               'rank': 3,
               'sklearn_classifier': MLPClassifier(activation='tanh', alpha=1.103855734598575e-05, beta_1=0.999,
                  beta_2=0.9, early_stopping=True,
                  hidden_layer_sizes=(229, 229, 229),
                  learning_rate_init=0.00014375616988222174, max_iter=32,
                  n_iter_no_change=32, random_state=1, verbose=0, warm_start=True)},
        5: {   'balancing': Balancing(random_state=1, strategy='weighting'),
               'classifier': <autosklearn.pipeline.components.classification.ClassifierChoice object at 0x7f099bdaf9d0>,
               'cost': 0.1063829787234043,
               'data_preprocessor': <autosklearn.pipeline.components.data_preprocessing.DataPreprocessorChoice object at 0x7f09a108cc70>,
               'ensemble_weight': 0.04,
               'feature_preprocessor': <autosklearn.pipeline.components.feature_preprocessing.FeaturePreprocessorChoice object at 0x7f099bdaf250>,
               'model_id': 5,
               'rank': 4,
               'sklearn_classifier': KNeighborsClassifier(n_neighbors=4, weights='distance')},
        6: {   'balancing': Balancing(random_state=1),
               'classifier': <autosklearn.pipeline.components.classification.ClassifierChoice object at 0x7f0997b58820>,
               'cost': 0.11347517730496459,
               'data_preprocessor': <autosklearn.pipeline.components.data_preprocessing.DataPreprocessorChoice object at 0x7f099ee44af0>,
               'ensemble_weight': 0.1,
               'feature_preprocessor': <autosklearn.pipeline.components.feature_preprocessing.FeaturePreprocessorChoice object at 0x7f09a1053940>,
               'model_id': 6,
               'rank': 5,
               'sklearn_classifier': SVC(C=100.5905006626969, cache_size=1810.546875, coef0=0.08087614244138486,
        gamma=0.011333066835975528, kernel='poly', max_iter=-1.0, random_state=1,
        tol=0.012391313886912093)},
        7: {   'balancing': Balancing(random_state=1, strategy='weighting'),
               'classifier': <autosklearn.pipeline.components.classification.ClassifierChoice object at 0x7f099cf353d0>,
               'cost': 0.03546099290780147,
               'data_preprocessor': <autosklearn.pipeline.components.data_preprocessing.DataPreprocessorChoice object at 0x7f099cb3b9a0>,
               'ensemble_weight': 0.12,
               'feature_preprocessor': <autosklearn.pipeline.components.feature_preprocessing.FeaturePreprocessorChoice object at 0x7f099cf35b80>,
               'model_id': 7,
               'rank': 6,
               'sklearn_classifier': LinearSVC(C=10.369811497206404, class_weight='balanced', dual=False,
              intercept_scaling=1.0, random_state=1, tol=0.0015130257264171173)},
        8: {   'balancing': Balancing(random_state=1, strategy='weighting'),
               'classifier': <autosklearn.pipeline.components.classification.ClassifierChoice object at 0x7f099c471610>,
               'cost': 0.04255319148936165,
               'data_preprocessor': <autosklearn.pipeline.components.data_preprocessing.DataPreprocessorChoice object at 0x7f099c988880>,
               'ensemble_weight': 0.14,
               'feature_preprocessor': <autosklearn.pipeline.components.feature_preprocessing.FeaturePreprocessorChoice object at 0x7f099d47e130>,
               'model_id': 8,
               'rank': 7,
               'sklearn_classifier': LinearDiscriminantAnalysis(tol=0.010552900863349885)},
        9: {   'balancing': Balancing(random_state=1),
               'classifier': <autosklearn.pipeline.components.classification.ClassifierChoice object at 0x7f099f741550>,
               'cost': 0.05673758865248224,
               'data_preprocessor': <autosklearn.pipeline.components.data_preprocessing.DataPreprocessorChoice object at 0x7f099c532400>,
               'ensemble_weight': 0.16,
               'feature_preprocessor': <autosklearn.pipeline.components.feature_preprocessing.FeaturePreprocessorChoice object at 0x7f099f7418e0>,
               'model_id': 9,
               'rank': 8,
               'sklearn_classifier': DecisionTreeClassifier(max_depth=1, min_samples_leaf=12, min_samples_split=10,
                           random_state=1)}}




.. GENERATED FROM PYTHON SOURCE LINES 77-82

Report statistics about the search
==================================

Print statistics about the auto-sklearn run such as number of
iterations, number of models failed with a time out etc.

.. GENERATED FROM PYTHON SOURCE LINES 82-84

.. code-block:: default

    print(automl.sprint_statistics())





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    auto-sklearn results:
      Dataset name: breast_cancer
      Metric: accuracy
      Best validation score: 0.971631
      Number of target algorithm runs: 8
      Number of successful target algorithm runs: 8
      Number of crashed target algorithm runs: 0
      Number of target algorithms that exceeded the time limit: 0
      Number of target algorithms that exceeded the memory limit: 0





.. GENERATED FROM PYTHON SOURCE LINES 85-92

Detailed statistics about the search - part 1
=============================================

Auto-sklearn also keeps detailed statistics of the hyperparameter
optimization procedurce, which are stored in a so-called
`run history <https://automl.github.io/SMAC3/master/apidoc/smac.
runhistory.runhistory.html#smac.runhistory.runhistory.RunHistory>`_.

.. GENERATED FROM PYTHON SOURCE LINES 92-95

.. code-block:: default


    print(automl.automl_.runhistory_)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    <smac.runhistory.runhistory.RunHistory object at 0x7f099cdb0550>




.. GENERATED FROM PYTHON SOURCE LINES 96-97

Runs are stored inside an ``OrderedDict`` called ``data``:

.. GENERATED FROM PYTHON SOURCE LINES 97-100

.. code-block:: default


    print(len(automl.automl_.runhistory_.data))





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    9




.. GENERATED FROM PYTHON SOURCE LINES 101-102

Let's iterative over all entries

.. GENERATED FROM PYTHON SOURCE LINES 102-108

.. code-block:: default


    for run_key in automl.automl_.runhistory_.data:
        print("#########")
        print(run_key)
        print(automl.automl_.runhistory_.data[run_key])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    #########
    RunKey(config_id=1, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.07801418439716312, time=2.3076725006103516, status=<StatusType.SUCCESS: 1>, starttime=1652703704.6709967, endtime=1652703707.003664, additional_info={'duration': 2.1896719932556152, 'num_run': 2, 'train_loss': 0.0, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=2, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.07092198581560283, time=1.9862322807312012, status=<StatusType.SUCCESS: 1>, starttime=1652703707.073907, endtime=1652703709.0891755, additional_info={'duration': 1.876880407333374, 'num_run': 3, 'train_loss': 0.06315789473684208, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=3, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.028368794326241176, time=2.0510802268981934, status=<StatusType.SUCCESS: 1>, starttime=1652703709.216941, endtime=1652703711.295177, additional_info={'duration': 1.974482536315918, 'num_run': 4, 'train_loss': 0.04210526315789476, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=4, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.1063829787234043, time=1.0138132572174072, status=<StatusType.SUCCESS: 1>, starttime=1652703711.4465065, endtime=1652703712.4845178, additional_info={'duration': 0.9386889934539795, 'num_run': 5, 'train_loss': 0.0, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=5, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.11347517730496459, time=0.883059024810791, status=<StatusType.SUCCESS: 1>, starttime=1652703712.6640482, endtime=1652703713.5770986, additional_info={'duration': 0.7946596145629883, 'num_run': 6, 'train_loss': 0.09122807017543855, 'configuration_origin': 'Initial design'})
    #########
    RunKey(config_id=6, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.03546099290780147, time=1.1183581352233887, status=<StatusType.SUCCESS: 1>, starttime=1652703717.0704563, endtime=1652703718.2143354, additional_info={'duration': 1.0354454517364502, 'num_run': 7, 'train_loss': 0.007017543859649145, 'configuration_origin': 'Random Search (sorted)'})
    #########
    RunKey(config_id=7, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.04255319148936165, time=1.1799671649932861, status=<StatusType.SUCCESS: 1>, starttime=1652703718.4552171, endtime=1652703719.659356, additional_info={'duration': 1.099785566329956, 'num_run': 8, 'train_loss': 0.06666666666666665, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=8, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=0.05673758865248224, time=0.9063131809234619, status=<StatusType.SUCCESS: 1>, starttime=1652703719.9214869, endtime=1652703720.8574393, additional_info={'duration': 0.821718692779541, 'num_run': 9, 'train_loss': 0.06315789473684208, 'configuration_origin': 'Random Search'})
    #########
    RunKey(config_id=9, instance_id='{"task_id": "breast_cancer"}', seed=0, budget=0.0)
    RunValue(cost=1.0, time=0.0, status=<StatusType.STOP: 8>, starttime=1652703725.5446618, endtime=1652703725.544662, additional_info={})




.. GENERATED FROM PYTHON SOURCE LINES 109-110

and have a detailed look at one entry:

.. GENERATED FROM PYTHON SOURCE LINES 110-114

.. code-block:: default


    run_key = list(automl.automl_.runhistory_.data.keys())[0]
    run_value = automl.automl_.runhistory_.data[run_key]








.. GENERATED FROM PYTHON SOURCE LINES 115-116

The ``run_key`` contains all information describing a run:

.. GENERATED FROM PYTHON SOURCE LINES 116-122

.. code-block:: default


    print("Configuration ID:", run_key.config_id)
    print("Instance:", run_key.instance_id)
    print("Seed:", run_key.seed)
    print("Budget:", run_key.budget)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Configuration ID: 1
    Instance: {"task_id": "breast_cancer"}
    Seed: 0
    Budget: 0.0




.. GENERATED FROM PYTHON SOURCE LINES 123-124

and the configuration can be looked up in the run history as well:

.. GENERATED FROM PYTHON SOURCE LINES 124-127

.. code-block:: default


    print(automl.automl_.runhistory_.ids_config[run_key.config_id])





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Configuration(values={
      'balancing:strategy': 'none',
      'classifier:__choice__': 'random_forest',
      'classifier:random_forest:bootstrap': 'True',
      'classifier:random_forest:criterion': 'gini',
      'classifier:random_forest:max_depth': 'None',
      'classifier:random_forest:max_features': 0.5,
      'classifier:random_forest:max_leaf_nodes': 'None',
      'classifier:random_forest:min_impurity_decrease': 0.0,
      'classifier:random_forest:min_samples_leaf': 1,
      'classifier:random_forest:min_samples_split': 2,
      'classifier:random_forest:min_weight_fraction_leaf': 0.0,
      'data_preprocessor:__choice__': 'feature_type',
      'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding',
      'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
      'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.01,
      'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean',
      'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize',
      'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 0,
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
      'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
      'feature_preprocessor:__choice__': 'pca',
      'feature_preprocessor:pca:keep_variance': 0.9999,
      'feature_preprocessor:pca:whiten': 'False',
    })





.. GENERATED FROM PYTHON SOURCE LINES 128-134

The only other important entry is the budget in case you are using
auto-sklearn with
:ref:`sphx_glr_examples_60_search_example_successive_halving.py`.
The remaining parts of the key can be ignored for auto-sklearn and are
only there because the underlying optimizer, SMAC, can handle more general
problems, too.

.. GENERATED FROM PYTHON SOURCE LINES 136-137

The ``run_value`` contains all output from running the configuration:

.. GENERATED FROM PYTHON SOURCE LINES 137-145

.. code-block:: default


    print("Cost:", run_value.cost)
    print("Time:", run_value.time)
    print("Status:", run_value.status)
    print("Additional information:", run_value.additional_info)
    print("Start time:", run_value.starttime)
    print("End time", run_value.endtime)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Cost: 0.07801418439716312
    Time: 2.3076725006103516
    Status: StatusType.SUCCESS
    Additional information: {'duration': 2.1896719932556152, 'num_run': 2, 'train_loss': 0.0, 'configuration_origin': 'Initial design'}
    Start time: 1652703704.6709967
    End time 1652703707.003664




.. GENERATED FROM PYTHON SOURCE LINES 146-152

Cost is basically the same as a loss. In case the metric to optimize for
should be maximized, it is internally transformed into a minimization
metric. Additionally, the status type gives information on whether the run
was successful, while the additional information's most interesting entry
is the internal training loss. Furthermore, there is detailed information
on the runtime available.

.. GENERATED FROM PYTHON SOURCE LINES 154-157

As an example, let's find the best configuration evaluated. As
Auto-sklearn solves a minimization problem internally, we need to look
for the entry with the lowest loss:

.. GENERATED FROM PYTHON SOURCE LINES 157-169

.. code-block:: default


    losses_and_configurations = [
        (run_value.cost, run_key.config_id)
        for run_key, run_value in automl.automl_.runhistory_.data.items()
    ]
    losses_and_configurations.sort()
    print("Lowest loss:", losses_and_configurations[0][0])
    print(
        "Best configuration:",
        automl.automl_.runhistory_.ids_config[losses_and_configurations[0][1]],
    )





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Lowest loss: 0.028368794326241176
    Best configuration: Configuration(values={
      'balancing:strategy': 'weighting',
      'classifier:__choice__': 'mlp',
      'classifier:mlp:activation': 'tanh',
      'classifier:mlp:alpha': 1.103855734598575e-05,
      'classifier:mlp:batch_size': 'auto',
      'classifier:mlp:beta_1': 0.9,
      'classifier:mlp:beta_2': 0.999,
      'classifier:mlp:early_stopping': 'valid',
      'classifier:mlp:epsilon': 1e-08,
      'classifier:mlp:hidden_layer_depth': 3,
      'classifier:mlp:learning_rate_init': 0.00014375616988222174,
      'classifier:mlp:n_iter_no_change': 32,
      'classifier:mlp:num_nodes_per_layer': 229,
      'classifier:mlp:shuffle': 'True',
      'classifier:mlp:solver': 'adam',
      'classifier:mlp:tol': 0.0001,
      'classifier:mlp:validation_fraction': 0.1,
      'data_preprocessor:__choice__': 'feature_type',
      'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding',
      'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer',
      'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.002766772136115771,
      'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent',
      'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer',
      'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 180,
      'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform',
      'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding',
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1,
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute',
      'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1,
      'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100,
      'feature_preprocessor:__choice__': 'pca',
      'feature_preprocessor:pca:keep_variance': 0.7895711479212801,
      'feature_preprocessor:pca:whiten': 'True',
    })





.. GENERATED FROM PYTHON SOURCE LINES 170-177

Detailed statistics about the search - part 2
=============================================

To maintain compatibility with scikit-learn, Auto-sklearn gives the
same data as
`cv_results_ <https://scikit-learn.org/stable/modules/generated/sklearn.
model_selection.GridSearchCV.html>`_.

.. GENERATED FROM PYTHON SOURCE LINES 177-180

.. code-block:: default


    print(automl.cv_results_)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    {'mean_test_score': array([0.92198582, 0.92907801, 0.97163121, 0.89361702, 0.88652482,
           0.96453901, 0.95744681, 0.94326241]), 'rank_test_scores': array([6, 5, 1, 7, 8, 2, 3, 4]), 'mean_fit_time': array([2.3076725 , 1.98623228, 2.05108023, 1.01381326, 0.88305902,
           1.11835814, 1.17996716, 0.90631318]), 'params': [{'balancing:strategy': 'none', 'classifier:__choice__': 'random_forest', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:random_forest:bootstrap': 'True', 'classifier:random_forest:criterion': 'gini', 'classifier:random_forest:max_depth': 'None', 'classifier:random_forest:max_features': 0.5, 'classifier:random_forest:max_leaf_nodes': 'None', 'classifier:random_forest:min_impurity_decrease': 0.0, 'classifier:random_forest:min_samples_leaf': 1, 'classifier:random_forest:min_samples_split': 2, 'classifier:random_forest:min_weight_fraction_leaf': 0.0, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'standardize', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.9999, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.01, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 0}, {'balancing:strategy': 'none', 'classifier:__choice__': 'random_forest', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:random_forest:bootstrap': 'True', 'classifier:random_forest:criterion': 'gini', 'classifier:random_forest:max_depth': 'None', 'classifier:random_forest:max_features': 0.9331254454871041, 'classifier:random_forest:max_leaf_nodes': 'None', 'classifier:random_forest:min_impurity_decrease': 0.0, 'classifier:random_forest:min_samples_leaf': 2, 'classifier:random_forest:min_samples_split': 20, 'classifier:random_forest:min_weight_fraction_leaf': 0.0, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'none', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.9967857433838874, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.005069923784737444, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'mlp', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:mlp:activation': 'tanh', 'classifier:mlp:alpha': 1.103855734598575e-05, 'classifier:mlp:batch_size': 'auto', 'classifier:mlp:beta_1': 0.9, 'classifier:mlp:beta_2': 0.999, 'classifier:mlp:early_stopping': 'valid', 'classifier:mlp:epsilon': 1e-08, 'classifier:mlp:hidden_layer_depth': 3, 'classifier:mlp:learning_rate_init': 0.00014375616988222174, 'classifier:mlp:n_iter_no_change': 32, 'classifier:mlp:num_nodes_per_layer': 229, 'classifier:mlp:shuffle': 'True', 'classifier:mlp:solver': 'adam', 'classifier:mlp:tol': 0.0001, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.7895711479212801, 'feature_preprocessor:pca:whiten': 'True', 'classifier:mlp:validation_fraction': 0.1, 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.002766772136115771, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 180, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'k_nearest_neighbors', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:k_nearest_neighbors:n_neighbors': 4, 'classifier:k_nearest_neighbors:p': 2, 'classifier:k_nearest_neighbors:weights': 'distance', 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'normalize', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.8047274080856589, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.008015420020402715, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1}, {'balancing:strategy': 'none', 'classifier:__choice__': 'libsvm_svc', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:libsvm_svc:C': 100.5905006626969, 'classifier:libsvm_svc:gamma': 0.011333066835975528, 'classifier:libsvm_svc:kernel': 'poly', 'classifier:libsvm_svc:max_iter': -1, 'classifier:libsvm_svc:shrinking': 'True', 'classifier:libsvm_svc:tol': 0.012391313886912093, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'minmax', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 100, 'feature_preprocessor:pca:keep_variance': 0.9290439925152777, 'feature_preprocessor:pca:whiten': 'False', 'classifier:libsvm_svc:coef0': 0.08087614244138486, 'classifier:libsvm_svc:degree': 3, 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.010000000000000004, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_absolute', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': 1}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'liblinear_svc', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:liblinear_svc:C': 10.369811497206404, 'classifier:liblinear_svc:dual': 'False', 'classifier:liblinear_svc:fit_intercept': 'True', 'classifier:liblinear_svc:intercept_scaling': 1, 'classifier:liblinear_svc:loss': 'squared_hinge', 'classifier:liblinear_svc:multi_class': 'ovr', 'classifier:liblinear_svc:penalty': 'l2', 'classifier:liblinear_svc:tol': 0.0015130257264171173, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'no_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'no_coalescense', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'mean', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'power_transformer', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding_distinct', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 137, 'feature_preprocessor:pca:keep_variance': 0.9677965620214456, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_choice': 'min_df_relative', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_relative': 0.08656832316003299}, {'balancing:strategy': 'weighting', 'classifier:__choice__': 'lda', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:lda:shrinkage': 'None', 'classifier:lda:tol': 0.010552900863349885, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'one_hot_encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'most_frequent', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'bag_of_word_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 2, 'feature_preprocessor:pca:keep_variance': 0.5940439727806581, 'feature_preprocessor:pca:whiten': 'True', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.0006032458390939325, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 1660, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'normal', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': 'min_df_relative', 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': 1, 'data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_relative': 0.36019594124973353}, {'balancing:strategy': 'none', 'classifier:__choice__': 'decision_tree', 'data_preprocessor:__choice__': 'feature_type', 'feature_preprocessor:__choice__': 'pca', 'classifier:decision_tree:criterion': 'gini', 'classifier:decision_tree:max_depth_factor': 0.09679641236056158, 'classifier:decision_tree:max_features': 1.0, 'classifier:decision_tree:max_leaf_nodes': 'None', 'classifier:decision_tree:min_impurity_decrease': 0.0, 'classifier:decision_tree:min_samples_leaf': 12, 'classifier:decision_tree:min_samples_split': 10, 'classifier:decision_tree:min_weight_fraction_leaf': 0.0, 'data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': 'encoding', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': 'minority_coalescer', 'data_preprocessor:feature_type:numerical_transformer:imputation:strategy': 'median', 'data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': 'quantile_transformer', 'data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': 'tfidf_encoding', 'data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': 15, 'feature_preprocessor:pca:keep_variance': 0.9889862560610739, 'feature_preprocessor:pca:whiten': 'False', 'data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': 0.016731911468974747, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': 373, 'data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': 'uniform', 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_choice': 'min_df_relative', 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:ngram_upper_bound': 2, 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:use_idf': False, 'data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_relative': 0.0969631806397533}], 'status': ['Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success', 'Success'], 'budgets': [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], 'param_balancing:strategy': masked_array(data=['none', 'none', 'weighting', 'weighting', 'none',
                       'weighting', 'weighting', 'none'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U9'), 'param_classifier:__choice__': masked_array(data=['random_forest', 'random_forest', 'mlp',
                       'k_nearest_neighbors', 'libsvm_svc', 'liblinear_svc',
                       'lda', 'decision_tree'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U19'), 'param_data_preprocessor:__choice__': masked_array(data=['feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type', 'feature_type',
                       'feature_type', 'feature_type'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U12'), 'param_feature_preprocessor:__choice__': masked_array(data=['pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca', 'pca'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U3'), 'param_classifier:adaboost:algorithm': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:adaboost:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:adaboost:max_depth': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:adaboost:n_estimators': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:bernoulli_nb:alpha': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:bernoulli_nb:fit_prior': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:decision_tree:criterion': masked_array(data=[--, --, --, --, --, --, --, 'gini'],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:decision_tree:max_depth_factor': masked_array(data=[--, --, --, --, --, --, --, 0.09679641236056158],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:max_features': masked_array(data=[--, --, --, --, --, --, --, 1.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, 'None'],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:decision_tree:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --, 0.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, 12.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, 10.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:decision_tree:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, 0.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_classifier:extra_trees:bootstrap': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:criterion': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:max_depth': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:max_features': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:min_impurity_decrease': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:min_samples_split': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:extra_trees:min_weight_fraction_leaf': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:early_stop': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:l2_regularization': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:loss': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:max_bins': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:max_depth': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:max_leaf_nodes': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:min_samples_leaf': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:scoring': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:tol': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:k_nearest_neighbors:n_neighbors': masked_array(data=[--, --, --, 4.0, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:k_nearest_neighbors:p': masked_array(data=[--, --, --, 2.0, --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:k_nearest_neighbors:weights': masked_array(data=[--, --, --, 'distance', --, --, --, --],
                 mask=[ True,  True,  True, False,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:lda:shrinkage': masked_array(data=[--, --, --, --, --, --, 'None', --],
                 mask=[ True,  True,  True,  True,  True,  True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:lda:tol': masked_array(data=[--, --, --, --, --, --, 0.010552900863349885, --],
                 mask=[ True,  True,  True,  True,  True,  True, False,  True],
           fill_value=1e+20), 'param_classifier:liblinear_svc:C': masked_array(data=[--, --, --, --, --, 10.369811497206404, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_classifier:liblinear_svc:dual': masked_array(data=[--, --, --, --, --, 'False', --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:fit_intercept': masked_array(data=[--, --, --, --, --, 'True', --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:intercept_scaling': masked_array(data=[--, --, --, --, --, 1.0, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_classifier:liblinear_svc:loss': masked_array(data=[--, --, --, --, --, 'squared_hinge', --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:multi_class': masked_array(data=[--, --, --, --, --, 'ovr', --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:penalty': masked_array(data=[--, --, --, --, --, 'l2', --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:liblinear_svc:tol': masked_array(data=[--, --, --, --, --, 0.0015130257264171173, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:C': masked_array(data=[--, --, --, --, 100.5905006626969, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:gamma': masked_array(data=[--, --, --, --, 0.011333066835975528, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:kernel': masked_array(data=[--, --, --, --, 'poly', --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:libsvm_svc:max_iter': masked_array(data=[--, --, --, --, -1.0, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:shrinking': masked_array(data=[--, --, --, --, 'True', --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:libsvm_svc:tol': masked_array(data=[--, --, --, --, 0.012391313886912093, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:activation': masked_array(data=[--, --, 'tanh', --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:alpha': masked_array(data=[--, --, 1.103855734598575e-05, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:batch_size': masked_array(data=[--, --, 'auto', --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:beta_1': masked_array(data=[--, --, 0.9, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:beta_2': masked_array(data=[--, --, 0.999, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:early_stopping': masked_array(data=[--, --, 'valid', --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:epsilon': masked_array(data=[--, --, 1e-08, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:hidden_layer_depth': masked_array(data=[--, --, 3.0, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:learning_rate_init': masked_array(data=[--, --, 0.00014375616988222174, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:n_iter_no_change': masked_array(data=[--, --, 32.0, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:num_nodes_per_layer': masked_array(data=[--, --, 229.0, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:shuffle': masked_array(data=[--, --, 'True', --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:solver': masked_array(data=[--, --, 'adam', --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:mlp:tol': masked_array(data=[--, --, 0.0001, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:passive_aggressive:C': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:passive_aggressive:average': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:passive_aggressive:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:passive_aggressive:loss': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:passive_aggressive:tol': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:qda:reg_param': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:random_forest:bootstrap': masked_array(data=['True', 'True', --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:random_forest:criterion': masked_array(data=['gini', 'gini', --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:random_forest:max_depth': masked_array(data=['None', 'None', --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:random_forest:max_features': masked_array(data=[0.5, 0.9331254454871041, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:max_leaf_nodes': masked_array(data=['None', 'None', --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_classifier:random_forest:min_impurity_decrease': masked_array(data=[0.0, 0.0, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_samples_leaf': masked_array(data=[1.0, 2.0, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_samples_split': masked_array(data=[2.0, 20.0, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:random_forest:min_weight_fraction_leaf': masked_array(data=[0.0, 0.0, --, --, --, --, --, --],
                 mask=[False, False,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:sgd:alpha': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:average': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:fit_intercept': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:learning_rate': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:loss': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:penalty': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:tol': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:categorical_transformer:categorical_encoding:__choice__': masked_array(data=['one_hot_encoding', 'no_encoding', 'no_encoding',
                       'no_encoding', 'one_hot_encoding', 'no_encoding',
                       'one_hot_encoding', 'encoding'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U16'), 'param_data_preprocessor:feature_type:categorical_transformer:category_coalescence:__choice__': masked_array(data=['minority_coalescer', 'minority_coalescer',
                       'minority_coalescer', 'minority_coalescer',
                       'minority_coalescer', 'no_coalescense',
                       'minority_coalescer', 'minority_coalescer'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U18'), 'param_data_preprocessor:feature_type:numerical_transformer:imputation:strategy': masked_array(data=['mean', 'mean', 'most_frequent', 'mean', 'mean',
                       'mean', 'most_frequent', 'median'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U13'), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:__choice__': masked_array(data=['standardize', 'none', 'quantile_transformer',
                       'normalize', 'minmax', 'power_transformer',
                       'quantile_transformer', 'quantile_transformer'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U20'), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:__choice__': masked_array(data=['bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding', 'bag_of_word_encoding',
                       'bag_of_word_encoding',
                       'bag_of_word_encoding_distinct',
                       'bag_of_word_encoding', 'tfidf_encoding'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U29'), 'param_data_preprocessor:feature_type:text_transformer:text_feature_reduction:n_components': masked_array(data=[100, 100, 100, 100, 100, 137, 2, 15],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value=999999), 'param_feature_preprocessor:pca:keep_variance': masked_array(data=[0.9999, 0.9967857433838874, 0.7895711479212801,
                       0.8047274080856589, 0.9290439925152777,
                       0.9677965620214456, 0.5940439727806581,
                       0.9889862560610739],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value=1e+20), 'param_feature_preprocessor:pca:whiten': masked_array(data=['False', 'False', 'True', 'False', 'False', 'False',
                       'True', 'False'],
                 mask=[False, False, False, False, False, False, False, False],
           fill_value='N/A',
                dtype='<U5'), 'param_classifier:gradient_boosting:n_iter_no_change': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:gradient_boosting:validation_fraction': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:lda:shrinkage_factor': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:libsvm_svc:coef0': masked_array(data=[--, --, --, --, 0.08087614244138486, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:libsvm_svc:degree': masked_array(data=[--, --, --, --, 3.0, --, --, --],
                 mask=[ True,  True,  True,  True, False,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:mlp:validation_fraction': masked_array(data=[--, --, 0.1, --, --, --, --, --],
                 mask=[ True,  True, False,  True,  True,  True,  True,  True],
           fill_value=1e+20), 'param_classifier:sgd:epsilon': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:eta0': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:l1_ratio': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_classifier:sgd:power_t': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:categorical_transformer:category_coalescence:minority_coalescer:minimum_fraction': masked_array(data=[0.01, 0.005069923784737444, 0.002766772136115771,
                       0.008015420020402715, 0.010000000000000004, --,
                       0.0006032458390939325, 0.016731911468974747],
                 mask=[False, False, False, False, False,  True, False, False],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:n_quantiles': masked_array(data=[--, --, 180.0, --, --, --, 1660.0, 373.0],
                 mask=[ True,  True, False,  True,  True,  True, False, False],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:quantile_transformer:output_distribution': masked_array(data=[--, --, 'uniform', --, --, --, 'normal', 'uniform'],
                 mask=[ True,  True, False,  True,  True,  True, False, False],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_max': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:numerical_transformer:rescaling:robust_scaler:q_min': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_choice': masked_array(data=['min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', 'min_df_absolute',
                       'min_df_absolute', --, 'min_df_relative', --],
                 mask=[False, False, False, False, False,  True, False,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:ngram_upper_bound': masked_array(data=[1.0, 1.0, 1.0, 1.0, 1.0, --, 1.0, --],
                 mask=[False, False, False, False, False,  True, False,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_choice': masked_array(data=[--, --, --, --, --, 'min_df_relative', --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:ngram_upper_bound': masked_array(data=[--, --, --, --, --, 1.0, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_choice': masked_array(data=[--, --, --, --, --, --, --, 'min_df_relative'],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value='N/A',
                dtype='<U32'), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:ngram_upper_bound': masked_array(data=[--, --, --, --, --, --, --, 2.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:use_idf': masked_array(data=[--, --, --, --, --, --, --, 0.0],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_absolute': masked_array(data=[0.0, 1.0, 1.0, 1.0, 1.0, --, --, --],
                 mask=[False, False, False, False, False,  True,  True,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding:min_df_relative': masked_array(data=[--, --, --, --, --, --, 0.36019594124973353, --],
                 mask=[ True,  True,  True,  True,  True,  True, False,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_absolute': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:bag_of_word_encoding_distinct:min_df_relative': masked_array(data=[--, --, --, --, --, 0.08656832316003299, --, --],
                 mask=[ True,  True,  True,  True,  True, False,  True,  True],
           fill_value=1e+20), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_absolute': masked_array(data=[--, --, --, --, --, --, --, --],
                 mask=[ True,  True,  True,  True,  True,  True,  True,  True],
           fill_value=1e+20,
                dtype=float64), 'param_data_preprocessor:feature_type:text_transformer:text_encoding:tfidf_encoding:min_df_relative': masked_array(data=[--, --, --, --, --, --, --, 0.0969631806397533],
                 mask=[ True,  True,  True,  True,  True,  True,  True, False],
           fill_value=1e+20)}




.. GENERATED FROM PYTHON SOURCE LINES 181-186

Inspect the components of the best model
========================================

Iterate over the components of the model and print
The explained variance ratio per stage

.. GENERATED FROM PYTHON SOURCE LINES 186-199

.. code-block:: default

    for i, (weight, pipeline) in enumerate(automl.get_models_with_weights()):
        for stage_name, component in pipeline.named_steps.items():
            if "feature_preprocessor" in stage_name:
                print(
                    "The {}th pipeline has a explained variance of {}".format(
                        i,
                        # The component is an instance of AutoSklearnChoice.
                        # Access the sklearn object via the choice attribute
                        # We want the explained variance attributed of
                        # each principal component
                        component.choice.preprocessor.explained_variance_ratio_,
                    )
                )




.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    The 0th pipeline has a explained variance of [0.45954164 0.18010277 0.09814953 0.06334655]
    The 1th pipeline has a explained variance of [0.98080571 0.01684553]
    The 2th pipeline has a explained variance of [0.4595393  0.18012072 0.09809101 0.06332899 0.0587162  0.03690793
     0.02471434 0.01657568 0.01327702 0.0102346  0.00829202 0.0068371
     0.00546871 0.00382248 0.00336889]
    The 3th pipeline has a explained variance of [0.46038401 0.16124884]
    The 4th pipeline has a explained variance of [0.44685232 0.17122959 0.1085501  0.07063243 0.06437417 0.03986668
     0.02462169 0.01589975 0.01257378 0.00948519 0.00858029]
    The 5th pipeline has a explained variance of [0.49503611 0.16649281 0.09111888 0.07213284 0.04865917 0.03208923
     0.01851537 0.01223987]
    The 6th pipeline has a explained variance of [4.32956881e-01 1.79057296e-01 1.11737571e-01 6.80724345e-02
     5.94611519e-02 3.70629898e-02 2.38430977e-02 1.49326086e-02
     1.37641366e-02 1.13704890e-02 1.03737258e-02 8.74116751e-03
     7.57629717e-03 4.86528503e-03 3.32225143e-03 2.55773043e-03
     2.20759805e-03 1.88675402e-03 1.36245140e-03 1.03409213e-03
     8.39749085e-04 7.91287172e-04 6.75655689e-04 5.42961621e-04
     5.02641737e-04 2.07827509e-04 1.74597367e-04]
    The 7th pipeline has a explained variance of [0.76699224 0.17152095]





.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 0 minutes  32.202 seconds)


.. _sphx_glr_download_examples_40_advanced_example_get_pipeline_components.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example


  .. container:: binder-badge

    .. image:: images/binder_badge_logo.svg
      :target: https://mybinder.org/v2/gh/automl/auto-sklearn/master?urlpath=lab/tree/notebooks/examples/40_advanced/example_get_pipeline_components.ipynb
      :alt: Launch binder
      :width: 150 px


  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: example_get_pipeline_components.py <example_get_pipeline_components.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: example_get_pipeline_components.ipynb <example_get_pipeline_components.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
